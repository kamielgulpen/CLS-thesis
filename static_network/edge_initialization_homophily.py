from pyclbr import Class
from networkx.algorithms.centrality import group

from itertools import product
import math
import random
import pandas as pd
import networkx as nx
import numpy as np
import multiprocessing as mp
import matplotlib.pyplot as plt
from pathlib import Path
import time

import scipy
from scipy.spatial import distance, distance_matrix
from scipy.spatial.distance import squareform 
from scipy import optimize

def simulate_uniform(N, ndim, a=0, b=1, **kwds):
    return np.random.uniform(a, b, (N, ndim)), None

def simulate_normal(N, ndim, mean=0, sd=1, **kwds):
    return np.random.normal(mean, sd, (N, ndim)), None

def simulate_lognormal(N, ndim, mean=0, sd=1, **kwds):
    return np.random.lognormal(mean, sd, (N, ndim)), None

def prob_function(d_ij, b, alpha):
    p_ij =1/( 1 + ((1/b * d_ij) ** alpha))
    
    return p_ij

def prob_1_0 (matrix):
    random_matrix = np.random.random(matrix.shape)
    
    return matrix > random_matrix

def root(system_size, d, alpha):

    def f(b):
        return 30 - ((1/system_size) * np.sum(np.sum(prob_function(d, b ,alpha))))
    
    sol = optimize.newton_krylov(f,  0.1, 10)

    return sol


def initialize_edges_links(df_edges,all_nodes, layer ,group_nodes, hash_dict, area_dict,node_area, id_source = None, id_destination = None, source = None, destination = None, barabasi = False, percentage=1, reciprocity=0):     
    '''
    Initializes the links based on the links per group instead of the probability
    '''   
    
    # Initialize all nodes with own link dictionary
    link_dictionary = {}

    for node in all_nodes:
        link_dictionary[node] = set()
      
    

    # Make from all strings integers so we do not have toe loop over pandas dataframe but over numpy array
    initial_list = []

    symetry_dict = {}


    for row in df_edges.iterrows():


        row = row[1]

        dst = hash_dict[f"{row['lft_dst']}, {row['etngrp_dst']}, {row['geslacht_dst']}, {row['oplniv_dst']}"]
        src = hash_dict[f"{row['lft_src']}, {row['etngrp_src']}, {row['geslacht_src']}, {row['oplniv_src']}"]

        initial_list.append(
            (
            dst,
            src,
            int(row['n'])
            )
            )
        
        symetry_dict[(src,dst)] = 0
    initial_list = np.array(initial_list)

    # Initializes the source and destinations lists if not multiprocessed
    if source == None and destination == None:
        source = []
        destination = []
        id_source = []
        id_destination = []

    total_edges = sum(df_edges['n'])

    edges_layd = 0
  
    # Loops through all connections (generated by the initialize node function) and makes links
    for row in initial_list:

        # Identifies source and destination group
        src_group = row[0]
        dst_group = row[1]
        connections = row[2]


        # If there are no connections between the source group and the destination group we continue
        if connections == 0:
            continue

        # Initialize dictionary with the node id as key and initial edges, 1, as value
        dst_nodes = [group_nodes[dst_group]]
        src_nodes = [group_nodes[src_group]]

        split = 1

        # print(len(dst_nodes[0]))
        # print(len(src_nodes[0]))
        
       
        if len(dst_nodes[0]) * len(src_nodes[0]) > 10000**2:
            dst_nodes_n = np.array_split(dst_nodes[0], 3)
            src_nodes_n = np.array_split(dst_nodes[0], 3)
            split = 3
        else:
            dst_nodes_n = dst_nodes
            src_nodes_n = dst_nodes

        for i in range(split):
            print('x')
            dst_nodes1 = dst_nodes_n[i]
            src_nodes1 = src_nodes_n[i]

            print(dst_nodes1)

            mx_s = np.random.uniform(0, 1, (len(src_nodes1), 2))
            mx_d = np.random.uniform(0, 1, (len(dst_nodes1), 2))

            system_size = system_size = (len(dst_nodes1) + len(src_nodes1))/2
            d = distance.cdist(mx_s, mx_d)
            
            
            alpha = 2
            sol = root(system_size, d, alpha)
            A = prob_1_0(prob_function(d, sol ,alpha))

            b = np.where(A==True)
            
            
            src_nodes_ = list(map(src_nodes1.__getitem__, b[0]))
            dst_nodes_ = list(map(dst_nodes1.__getitem__, b[1]))

            source.extend([src_group] * A.shape[0])
            destination.extend([dst_group] * A.shape[0])

            id_source.extend(src_nodes_)
            id_destination.extend(dst_nodes_)
                # link_dictionary[src_node].add(dst_node)


            

  
    return source, destination, id_source, id_destination