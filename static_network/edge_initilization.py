from pyclbr import Class
from networkx.algorithms.centrality import group

from descriptive import Person_links

from itertools import product
import math
import random
import pandas as pd
import networkx as nx
import numpy as np
import multiprocessing as mp
import matplotlib.pyplot as plt
from pathlib import Path
import time



def initialize_edges_links(df_edges,all_nodes, layer ,group_nodes, hash_dict, area_dict,node_area, id_source = None, id_destination = None, source = None, destination = None, barabasi = False, percentage=False, reciprocity=0, spatial = False):     
    '''
    Initializes the links based on the links per group instead of the probability
    '''   


    # Initialize all nodes with own link dictionary
    link_dictionary = {}

    for node in all_nodes:
        link_dictionary[node] = set()
      
    

    # Make from all strings integers so we do not have toe loop over pandas dataframe but over numpy array
    initial_list = []

    symetry_dict = {}


    for row in df_edges.iterrows():


        row = row[1]

        dst = hash_dict[f"{row['lft_dst']}, {row['etngrp_dst']}, {row['geslacht_dst']}, {row['oplniv_dst']}"]
        src = hash_dict[f"{row['lft_src']}, {row['etngrp_src']}, {row['geslacht_src']}, {row['oplniv_src']}"]

        initial_list.append(
            (
            dst,
            src,
            int(row['n'])
            )
            )


    
        symetry_dict[(src,dst)] = 0
    initial_list = np.array(initial_list)

        
    # If layer is huishouden or familie set symetric to True
    if layer == 'huishouden' or layer == 'familie':
        reciprocity = 1

    
    # Initializes the source and destinations lists if not multiprocessed
    if source == None and destination == None:
        source = []
        destination = []
        id_source = []
        id_destination = []

    total_edges = sum(df_edges['n'])

    edges_layd = 0
    len(initial_list)

    
  
    # Loops through all connections (generated by the initialize node function) and makes links
    for row in initial_list:

        # Identifies source and destination group
        src_group = row[0]
        dst_group = row[1]
        connections = row[2]

 

        # If te data is symetric (familie, household), initiate a dictionary for the destination group

        
        if reciprocity and (src_group, dst_group) in symetry_dict:
    
            connections = connections - symetry_dict[(src_group, dst_group)]

        # print(connections)
        # If there are no connections between the source group and the destination group we continue
        if connections == 0:
            continue

        # Initialize dictionary with the node id as key and initial edges, 1, as value
        dst_nodes = group_nodes[dst_group]
        src_nodes = group_nodes[src_group]

            
        # If Barabasi parameter is on take a sample to put in the initial bin (1 percent is standard)

        if barabasi: 
            
            dst_nodes_bin = random.sample(dst_nodes, k=(math.ceil(len(dst_nodes)*(percentage/100))))
        
        i = 0

        while i < connections:

            if edges_layd % 100000 == 1:
                # print(symetry_dict)
                print(edges_layd/total_edges)
                print(edges_layd)
    
                
            
            while True:
                
                # Take random source node and destination node based on the groups
                if len(src_nodes) > 0 and len(dst_nodes) > 0:
                    
                    src_node = random.choices(src_nodes)[0]
                    dst_node = random.choices(dst_nodes)[0]
                    
                    
                    # CHECK IN WHICH AREA HE IS FROM ==> MAKE DICTIONARY WHERE NODE IS KEY AND AREA IS VALUE
                    # CHOOSE A RANDOM OTHE NODE FROM THAT AREA WITH GROUP SPECIFICS ==> MAKE DICTIONARY WHERE AREA AND GROUP IS KEY AND LIST OF NODES IS VALUE
                    if layer == 'buren' and spatial:
                        
                        
                        # Get area of source group
                        area = node_area[src_node]

                        if np.random.uniform() < 0.01:

                            if np.random.uniform()<0.5:
                                area += 1
                            else :
                                area -= 1
                                
                            area %= 99

                        # Get nodes based on area source group and destination group
                        dst_area_nodes = area_dict[area][dst_group]

                        if len(dst_area_nodes) > 0:
                            dst_node = random.choices(dst_area_nodes)[0]
                        else:
                            dst_node = random.choices(dst_nodes)[0]
                    # Take random node from the bin
                    if barabasi: dst_node = random.choices(dst_nodes_bin)[0]
                   
             
                else:
                   
                    break
           

                # Checks if the source and destination node are not the same and checks if they aren't already linked
                if dst_node != src_node and dst_node not in link_dictionary[src_node]:
                    
                    # # If Barabasi append a random node to the bin
                    if barabasi:
                        dst_nodes_bin.append(random.choices(dst_nodes)[0])
               
                        # Add the chosen node to the bin so the chosen node gets a higher weight 
                        if np.random.uniform() < barabasi : dst_nodes_bin.append(dst_node)

                        

                    # Appends both nodes to lists
                    if reciprocity > np.random.uniform() and src_node not in link_dictionary[dst_node] and (src_group, dst_group) in symetry_dict:

                       
                        source.append(dst_group)
                        destination.append(src_group)
                        link_dictionary[dst_node].add(src_node)
                    
                        id_source.append(dst_node)
                        id_destination.append(src_node)
                        
                        symetry_dict[(dst_group, src_group)] += 1
                    
                        if dst_nodes == src_nodes:
                            i += 1

                    source.append(src_group)
                    destination.append(dst_group)
                
                    id_source.append(src_node)
                    id_destination.append(dst_node)

                    link_dictionary[src_node].add(dst_node)

                    break
                
            edges_layd += 1
            i += 1

    print(edges_layd)
   
    return source, destination, id_source, id_destination


